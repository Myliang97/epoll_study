/*************************************************************/
 Copyright (c) Liang 2019 
 说明:
 整个系统分为两大部分:
 1.epoll_heap
 2.pthread_pool
 这是程序是我学习Linux多线程高并发处理时写下的，数据结构封装，函数接口
 均是自己设计，如果你认为有需要改动的，你可以commit，谢谢。
 参考:
 epoll反应堆模型
 线程池模型
epoll:
    epoll用于Linux下多路IO复用的情况，能显著提高并发。epoll和select/poll
不同，epoll只会返回那些触发的事件，并通过epoll_wait()的传出参数返回，我们将
会获得一个数组，这个数组保存了那些被触发的事件。获得这些事件后，我们可以进一步
处理。
    epoll_wait()函数原型：
        int epoll_wait(int epfd, struct epoll_event *events,
                                int maxevents, int timeout);
    struct epoll_event类型的结构体正是我们需要的事件结构体，这个结构体有一个
非常重要的成员: 
    epoll_data_t data;
    这是个联合体，声明如下：
        typedef union epoll_data {
                void    *ptr;
                int      fd;
                uint32_t u32;
                uint64_t u64;
            } epoll_data_t;
    它的成员有个void*类型的指针，那么如果将这指针指向一个结构体，而这个结构体里面
有个函数指针，这个函数指针指向的正是事件要执行的函数!

任务队列:
    在上面谈到，利用epoll_data中的ptr让其执行处理函数。但当触发的事件数量巨大时，
明显我们需要多线程/多进程。触发的事件，我们先保存在一个数组中，等待线程执行，这个数组
叫做任务队列。

pthread_pool:
    线程池在程序开始运行，先创建一部分线程阻塞等待任务，一旦任务队列出现非空，线程们
就应该开始去竞争获取任务了。但如果任务非常多，线程数量明显不足，是不是要考虑增加线程
数量呢?反之，当任务队列的任务被执行得差不多了，我们临时创建出来的线程数量过多时，是不
是需要减少线程数量呢?为此，我们需要一个专门管理这些线程生死的线程。
    为了更好地调度所有的资源，我添加了一个在pthread_pool全局的控制器，保存着任务队列，
线程池，管理者线程等等的信息。

***************************************************************/